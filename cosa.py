def m_performance(k_list):
    return min(k_list[i]*ij_performance(solution[self.s:][i],i) for i in range(len(k_list))

def ij_performance(version,component):
    return self.W[component][version]

#def m_sort(solution,k_lists):
#    return sorted(k_lists,key=lambda k:m_performance(solution,k)}

def delta_summ(k_interval,k_lists):
    m_sort = lambda s,k: sorted(k_lists,key=lambda k:m_performance(k)}
    return self.W_T[k_interval][1]*sum(delta(m) for m in range(len(m_sort(k_lists)) if m_performance(m)>=W_T[k_interval][0])

def delta(m):
    alpha = lambda k,x_i,a_ij: binom.pmf(k,x_i,a_ij)
    return np.prod([alpha(m[k],solution[:s][k],self.A[k][solution[s:][k]) for k in range(len(m))])
    


